import sys, time

# Wrapper around SGA's FM-index implementation.

type Intv(lower: int, upper: int):
    def __init__(self: Intv) -> Intv:
        return (0, 0)

    def __init__(self: Intv, lower: int, upper: int) -> Intv:
        return (lower, upper)

    # isValid()
    def __bool__(self: Intv):
        return self.lower <= self.upper

    # size()
    def __len__(self: Intv):
        return self.upper - self.lower - 1

type FMIndex(p: ptr[byte]):
    def __init__(self: FMIndex, path: str) -> FMIndex:
        # extern "C" void *sga_idx_new(const char *path)
        cdef sga_idx_new(path: ptr[byte]) -> ptr[byte]
        return (sga_idx_new(path.ptr),)

    def __getitem__(self: FMIndex, key: tuple[Intv, seq]):
        # extern "C" void sga_update_interval(void *bwt, BWTInterval *interval, char b)
        cdef sga_update_interval(bwt: ptr[byte], interval: ptr[Intv], b: byte)
        v, b = key
        sga_update_interval(self.p, __ptr__(v), b.ptr[0])
        return v

    def __getitem__(self: FMIndex, b: seq):
        # extern "C" void sga_init_interval(void *bwt, BWTInterval *interval, char b)
        cdef sga_init_interval(bwt: ptr[byte], interval: ptr[Intv], b: byte)
        v = Intv()
        sga_init_interval(self.p, __ptr__(v), b.ptr[0])
        return v

    def __prefetch__(self: FMIndex, key: tuple[Intv, seq]):
        # extern "C" void sga_update_interval_prefetch(void *bwt, int64_t lower, int64_t upper, char b)
        cdef sga_update_interval_prefetch(bwt: ptr[byte], lower: int, upper: int, b: byte)
        v, b = key
        sga_update_interval_prefetch(self.p, v.lower, v.upper, b.ptr[0])

type K = k20

def filter(kmer: seq):
    if not kmer.N(): yield kmer

def lookup(kmer: seq, index: FMIndex):
    j = len(kmer) - 1
    iv = index[kmer[j]]
    j -= 1
    while j >= 0:
        iv = index[(iv, kmer[j])]
        j -= 1
        if not iv:
            return iv
    return iv

def lookup_p(kmer: seq, index: FMIndex):
    j = len(kmer) - 1
    iv = index[kmer[j]]
    j -= 1
    while j >= 0:
        prefetch index[(iv, kmer[j])]
        iv = index[(iv, kmer[j])]
        j -= 1
        if not iv:
            return iv
    return iv

good, bad = 0, 0
def count(iv: Intv):
    global good, bad
    if iv:
        good += 1
    else:
        bad += 1

def main(args):
    t=time.time()
    index = FMIndex(args[0])
    sys.stderr.write('index loading:' +  str((time.time()-t)/1000.0) + "\n")
    match args[2]:
        case 'n': 
            fastq(args[1]) |> split(K.len(), 1) |> filter |> lookup(index) |> count
        case 'y': 
            fastq(args[1]) |> split(K.len(), 1) |> filter |> lookup_p(index) |> count
        default:
            print 'bad mode'
            sys.exit(1)
    print good, bad

if len(sys.argv) > 0:
    main(sys.argv[1:])
